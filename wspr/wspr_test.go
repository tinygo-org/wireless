/*
 * Portions of this code copyright 2025 Ted Dunning
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package wspr

import (
	"fmt"
	"slices"
	"strconv"
	"strings"
	"testing"
)

func TestBitParity(t *testing.T) {
	for _, test := range []struct {
		in  uint32
		out int
	}{
		{3001212665, 0},
		{271209980, 0},
		{1060132770, 0},
		{2822695309, 1},
		{1604907376, 1},
		{3561693668, 0},
		{30495908, 1},
		{676694378, 1},
		{796632199, 0},
		{4107319043, 0},
	} {
		if parity32(test.in) != test.out {
			t.Errorf("Parity(%d)=%d, want %d", test.in, test.out, test.in)
		}
	}
}

func TestEncode(t *testing.T) {
	for _, test := range []struct {
		name     string
		input    string
		expected []byte
		wantErr  bool
	}{
		{
			"Example from wikipedia",
			"K1ABC FN42 37",
			[]byte{
				3, 3, 0, 0, 2, 0, 0, 0, 1, 0, 2, 0, 1, 3, 1, 2, 2, 2, 1, 0,
				0, 3, 2, 3, 1, 3, 3, 2, 2, 0, 2, 0, 0, 0, 3, 2, 0, 1, 2, 3,
				2, 2, 0, 0, 2, 2, 3, 2, 1, 1, 0, 2, 3, 3, 2, 1, 0, 2, 2, 1,
				3, 2, 1, 2, 2, 2, 0, 3, 3, 0, 3, 0, 3, 0, 1, 2, 1, 0, 2, 1,
				2, 0, 3, 2, 1, 3, 2, 0, 0, 3, 3, 2, 3, 0, 3, 2, 2, 0, 3, 0,
				2, 0, 2, 0, 1, 0, 2, 3, 0, 2, 1, 1, 1, 2, 3, 3, 0, 2, 3, 1,
				2, 1, 2, 2, 2, 1, 3, 3, 2, 0, 0, 0, 0, 1, 0, 3, 2, 0, 1, 3,
				2, 2, 2, 2, 2, 0, 2, 3, 3, 2, 3, 2, 3, 3, 2, 0, 0, 3, 1, 2, 2, 2,
			},
			false,
		},
		{
			"Example from https://mpb.li/git/picardy/tree/sw/eval-clock-cw-tx/README.md",
			"HB9EGM JN36 30",
			[]byte{
				1, 1, 2, 0, 0, 2, 2, 2, 1, 2, 0, 0, 3, 3, 1, 0, 2, 2, 3, 2, // 0...
				0, 1, 0, 1, 3, 3, 1, 0, 2, 2, 0, 0, 2, 0, 3, 2, 0, 3, 0, 1, // 20...
				2, 0, 2, 0, 2, 0, 3, 2, 1, 1, 0, 2, 3, 3, 0, 3, 0, 2, 2, 3, // 40...
				1, 0, 3, 0, 2, 2, 0, 1, 3, 2, 3, 0, 3, 2, 3, 0, 1, 0, 0, 3, // 60...
				0, 0, 1, 2, 1, 3, 0, 2, 2, 1, 3, 2, 3, 0, 3, 2, 0, 0, 3, 2, // 80...
				0, 0, 0, 2, 3, 2, 0, 1, 2, 0, 1, 1, 1, 0, 3, 1, 2, 2, 1, 1, // 100...
				0, 3, 2, 2, 2, 1, 1, 1, 0, 0, 2, 2, 2, 3, 0, 3, 2, 2, 3, 3, // 120...
				0, 0, 2, 2, 2, 2, 0, 3, 3, 0, 1, 2, 1, 3, 0, 0, 0, 1, 1, 2, 2, 0}, // 140..161
			false,
		},
		{
			"generated by https://swharden.com/software/wspr-code-generator/",
			"W8ZLW AA00 3",
			[]byte{
				3, 1, 2, 2, 0, 0, 0, 0, 1, 0, 0, 0, 3, 3, 3, 2, 2, 2, 1, 0,
				0, 1, 0, 3, 3, 3, 1, 0, 2, 2, 2, 0, 0, 0, 3, 2, 2, 1, 2, 3,
				2, 2, 2, 0, 0, 0, 3, 2, 3, 3, 2, 2, 3, 1, 0, 1, 2, 0, 2, 3,
				1, 0, 1, 2, 2, 0, 2, 1, 3, 2, 1, 0, 1, 0, 1, 2, 1, 0, 0, 1,
				0, 2, 3, 2, 1, 1, 2, 0, 0, 3, 3, 2, 1, 2, 3, 0, 2, 0, 3, 2,
				2, 2, 2, 0, 1, 2, 2, 3, 0, 2, 3, 1, 3, 0, 3, 1, 2, 0, 1, 3,
				0, 1, 0, 0, 0, 1, 3, 3, 2, 0, 0, 0, 0, 1, 0, 1, 0, 0, 3, 3,
				2, 2, 0, 0, 2, 2, 2, 1, 1, 2, 3, 0, 1, 1, 2, 0, 2, 3, 3, 0, 2, 0,
			},
			false,
		},
	} {
		t.Run(test.name, func(t *testing.T) {
			s := strings.Split(test.input, " ")
			power, err := strconv.ParseInt(s[2], 10, 0)
			if err != nil {
				t.Fatalf("broken test: %e", err)
			}

			msg, err := NewMessage(s[0], s[1], int(power))
			if err != nil {
				t.Fatalf("NewMessage error = %v, wantErr %v", err, test.wantErr)
			}
			got := make([]byte, 162)
			n, err := msg.WriteSymbols(got)
			if (err != nil) != test.wantErr {
				t.Fatalf("Encode() error = %v, wantErr %v", err, test.wantErr)
			} else if n != 162 {
				t.Fatalf("expected 162 bytes written, got %d", n)
			}

			if got != nil && slices.Compare(got, test.expected) != 0 {
				fmt.Printf("error in encoding\n")
				vector_diff(got, test.expected)
				t.Errorf("encoded message differs from expected")
			}
		})
	}
}

func TestParity(t *testing.T) {
	for _, test := range []struct {
		name        string
		in          Message
		parity      []byte
		interleaved []byte
	}{
		{"K1ABC",
			0xF7_0C_23_8B_0D_19_40,
			[]byte{
				1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0,
				1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1,
				1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1,
				1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0,
				1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1,
				1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0,
				1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1,
				0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1,
			},
			[]byte{
				1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0,
				0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1,
				1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0,
				1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0,
				1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0,
				1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0,
				1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1,
				1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1,
			},
		},
		{
			"HB9EGM",
			0x75_1D_C4_F7_A0_17_80,
			[]byte{
				0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0,
				0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0,
				1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1,
				1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1,
				0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0,
				1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0,
				0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1,
				1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0,
			},
			[]byte{
				0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1,
				0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0,
				1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1,
				0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1,
				0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1,
				0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0,
				0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
				0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0,
			},
		},
		{
			"W8ZLW",
			0xF9_72_F2_8F_BB_90_C0,
			nil,
			[]byte{
				1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0,
				0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1,
				1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1,
				0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
				0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1,
				1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1,
				0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
				1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0,
			},
		},
	} {
		t.Run(test.name, func(t *testing.T) {
			got := make([]byte, 162)
			_, err := test.in.WriteParitySymbols(got)
			if err != nil {
				t.Fatalf("Parity() error = %v", err)
			}

			if test.parity != nil {
				flag := false
				for i := 0; i < len(got); i++ {
					if got[i] != test.parity[i] {
						flag = true
						break
					}
				}
				if flag {
					fmt.Printf("in=%x, parity problem\n", test.in)
					vector_diff(got, test.parity)
				}
			}

			interleave(got)
			flag := false
			for i := 0; i < len(got); i++ {
				if got[i] != test.interleaved[i] {
					flag = true
					break
				}
			}
			if flag {
				fmt.Printf("in=%x, interleave problem\n", test.in)
				vector_diff(got, test.interleaved)
			}
		})
	}
}

func vector_print(got []byte) {
	for i := 0; i < len(got); i++ {
		fmt.Printf("%d", got[i])
	}
	fmt.Printf("\n")
}

func vector_diff(got []byte, expected []byte) {
	vector_print(got)
	vector_print(expected)
	for i := 0; i < len(got); i++ {
		if got[i] == expected[i] {
			fmt.Printf(" ")
		} else {
			fmt.Printf("x")
		}
	}
	fmt.Printf("\n")
}

func TestSourceEncoding(t *testing.T) {
	for _, test := range []struct {
		name     string
		input    string
		expected uint64
		wantErr  bool
	}{
		{
			"Example from wikipedia",
			"K1ABC FN42 37",
			0xF7_0C_23_8B_0D_19_40,
			false,
		},
		{
			"Example from https://mpb.li/git/picardy/tree/sw/eval-clock-cw-tx/README.md",
			"HB9EGM JN36 30",
			0x75_1D_C4_F7_A0_17_80,
			false,
		},
		{
			"test case from https://swharden.com/software/wspr-code-generator/",
			"W8ZLW AA00 3",
			0xF972F28FBB90C0,
			false,
		},
	} {
		// end-to-end message encoding from call-sign, locator and power to 50-bit compressed form
		t.Run(test.name, func(t *testing.T) {
			s := strings.Split(test.input, " ")
			power, err := strconv.ParseInt(s[2], 10, 0)
			if err != nil {
				t.Fatalf("broken test: %e", err)
			}
			got, err := NewMessage(s[0], s[1], int(power))
			if (err != nil) != test.wantErr {
				t.Errorf("PackBits() error = %v, wantErr %v", err, test.wantErr)
			}
			if got != Message(test.expected) {
				t.Errorf("PackBits() got = %v, want %v", got, test.expected)
			}
		})
		// subtest for power encoding
		t.Run(test.name+" (power)", func(t *testing.T) {
			s := strings.Split(test.input, " ")[2]
			power, err := strconv.ParseInt(s, 10, 0)
			if err != nil {
				t.Fatalf("broken test: %e", err)
			}
			got := Power(int(power))
			expect := (test.expected >> 6) & 0x7f
			if got != expect {
				t.Errorf("Power(%d): got %d, want %d", power, got, expect)
			}
		})
		// subtest for call-sign encoding
		t.Run(test.name+" (call-sign)", func(t *testing.T) {
			callsign := strings.Split(test.input, " ")[0]
			call, err := CallSign(callsign)
			if test.wantErr && err == nil {
				t.Errorf("CallSign(%q) expected error", callsign)
			}
			if !test.wantErr && err != nil {
				t.Errorf("CallSign(%q) unexpected error: %v", callsign, err)
			}
			expected := test.expected >> 28
			if call != expected {
				t.Errorf("CallSign(%q) got %d, want %d", callsign, call, expected)
			}
		})
		// subtest for location encoding
		t.Run(test.name+" (locator)", func(t *testing.T) {
			locator := strings.Split(test.input, " ")[1]
			loc, err := Locator(locator)
			expected := (test.expected >> 13) & 0x7fff
			if test.wantErr && err == nil {
				t.Errorf("Locator(%q) expected error", locator)
			}
			if !test.wantErr && err != nil {
				t.Errorf("Locator(%q) unexpected error: %v", locator, err)
			}
			if loc != expected {
				t.Errorf("Locator(%q) got %d, want %d", locator, loc, expected)
			}
		})
	}
}

func TestLocator(t *testing.T) {
	for _, test := range []struct {
		name    string
		locator string
		result  uint64
		wantErr bool
	}{
		{"low end", "AA00", 32220, false},
		{"low end", "aa00", 32220, false},
		{"high end", "RR99", 179, false},
		{"high end", "rr99", 179, false},

		{"mid 1", "AA02", 179*180 + 2, false},
		{"mid 2", "AA20", (179-2)*180 + 0, false},
		{"mid 3", "Ac00", 179*180 + 20, false},
		{"mid 4", "cA00", (179-20)*180 + 0, false},
		{"mid 4", "FN42", 22632, false},

		{"too short", "RR9", 0, true},
		{"too long", "RR993", 0, true},
		{"bad char 1", "xR01", 0, true},
		{"bad char 2", "AR0x", 0, true},
	} {
		t.Run(test.name, func(t *testing.T) {
			got, err := Locator(test.locator)
			if !test.wantErr && (err != nil) {
				t.Errorf("%s (%q): got unexpected error %v", test.name, test.locator, err)
			}
			if test.wantErr && (err == nil) {
				t.Errorf("%s (%q): got unexpected success", test.name, test.locator)
			}
			if got != test.result {
				t.Errorf("%s (%q): got %d, want %d", test.name, test.locator, got, test.result)
			}
		})
	}
}

func Test_encodeChar(t *testing.T) {
	type args struct {
		c           byte
		legalValues int
		encoded     uint64
	}
	tests := []struct {
		name    string
		args    args
		want    uint64
		wantErr bool
	}{
		{"upper case 0a", args{'E', ALPHA, 0}, 4, false},
		{"lower case 0a", args{'e', ALPHA, 0}, 4, false},
		{"upper case 0ad", args{'E', ALPHA | DIGIT, 0}, 4 + 10, false},
		{"lower case 0ad", args{'e', ALPHA | DIGIT, 0}, 4 + 10, false},
		{"lower case 0as", args{'e', ALPHA | SPACE, 0}, 4, false},
		{"upper case 1", args{'C', ALPHA | DIGIT, 101}, 101*36 + 2 + 10, false},
		{"upper case 2", args{'F', ALPHA | DIGIT, 101}, 101*36 + 5 + 10, false},
		{"upper case 3", args{'F', ALPHA | SPACE, 101}, 101*27 + 5, false},
		{"upper case 4", args{'F', ALPHA | SPACE | DIGIT, 101}, 101*37 + 5 + 10, false},
		{"lower case 1", args{'c', ALPHA, 101}, 101*26 + 2, false},
		{"lower case 2", args{'f', ALPHA | DIGIT, 101}, 101*36 + 5 + 10, false},
		{"lower case 3", args{'f', ALPHA | SPACE, 101}, 101*27 + 5, false},
		{"lower case 4", args{'f', ALPHA | SPACE | DIGIT, 101}, 101*37 + 5 + 10, false},
		{"space 0", args{' ', ALPHA | SPACE | DIGIT, 0}, 36, false},
		{"space 0a", args{' ', ALPHA | SPACE | DIGIT, 101}, 101*37 + 36, false},
		{"space 1", args{' ', ALPHA | SPACE, 101}, 101*27 + 26, false},
		{"space 2", args{' ', DIGIT | SPACE, 101}, 101*11 + 10, false},
		{"digit 1", args{'5', DIGIT, 101}, 101*10 + 5, false},
		{"digit 2", args{'7', ALPHA | DIGIT, 101}, 101*36 + 7, false},
		{"digit 3", args{'3', ALPHA | DIGIT | SPACE, 101}, 101*37 + 3, false},
		{"maidenhead 1", args{'c', MAIDENHEAD, 101}, 101*18 + 2, false},
		{"maidenhead 2", args{'F', MAIDENHEAD, 101}, 101*18 + 5, false},

		{"bad maidenhead", args{'x', MAIDENHEAD, 101}, 0, true},
		{"bad maidenhead spec 1", args{'e', MAIDENHEAD | ALPHA, 101}, 0, true},
		{"bad maidenhead spec 2", args{'e', MAIDENHEAD | DIGIT, 101}, 0, true},
		{"bad digit", args{'x', DIGIT | SPACE, 101}, 0, true},
		{"bad alpha", args{'3', ALPHA | SPACE, 101}, 0, true},
		{"illegal digit", args{'3', ALPHA | SPACE, 101}, 0, true},
		{"illegal alpha", args{'x', DIGIT | SPACE, 101}, 0, true},
		{"illegal space", args{' ', ALPHA | DIGIT, 101}, 0, true},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := encodeChar(tt.args.c, tt.args.legalValues, tt.args.encoded)
			if (err != nil) != tt.wantErr {
				t.Errorf("encodeChar() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if got != tt.want {
				t.Errorf("encodeChar() got = %v, want %v", got, tt.want)
			}
		})
	}
}
